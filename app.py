# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g_h62g5r7tcMDNKmEux1AwMjQ4Oa8Pce
"""

# ==============================================================================
# 1. IMPORTS Y CONFIGURACI칍N INICIAL
# ==============================================================================
import streamlit as st
import pandas as pd
import plotly.express as px
import pmdarima as pm
import numpy as np

# 2. CONFIGURACI칍N DE P츼GINA
st.set_page_config(
    page_title="GEI-Colombia Data Insights",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ------------------------------------------------------------------------------
# 3. FUNCI칍N DE LIMPIEZA Y CARGA (USANDO CACHE) - Fase 1
# ------------------------------------------------------------------------------
@st.cache_data
def load_and_clean_data(file_path):
    # Cargar datos
    df = pd.read_csv(file_path)

    # Limpieza de A칌O y columnas num칠ricas clave
    df['A칌O'] = df['A칌O'].astype(str).str.replace(',', '', regex=True).str.strip()
    df['A칌O'] = pd.to_numeric(df['A칌O'], errors='coerce').fillna(0).astype(int)

    numeric_cols = ['Total_Emisiones', 'Absorciones', 'Emisiones_netas']
    for col in numeric_cols:
        if col in df.columns:
            df[col] = df[col].astype(str).str.replace(',', '', regex=True).str.strip()
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)

    # Filtrar solo los agregados principales y 'Nacional'
    major_prefixes = ['1 ', '2 ', '3 ', '4 ', '5 ']
    df_filtered = df[
        (df['CLASIFICACION'].str.contains('|'.join(major_prefixes), na=False) &
        (~df['CLASIFICACION'].str.contains(r'\.\w', regex=True, na=False))) |
        (df['CLASIFICACION'] == 'Nacional')
    ].copy()

    df_filtered = df_filtered.rename(columns={'CLASIFICACION': 'Sector'})

    return df_filtered

# 4. EJECUCI칍N INICIAL DE LA CARGA (Define las variables globales)
try:
    data_path = 'Inventario_Nacional_Gases_Efecto_Invernadero_20251121.csv'
    df = load_and_clean_data(data_path)

    # VARIABLES GLOBALES DEFINIDAS AQU칈
    available_years = sorted(df['A칌O'].unique(), reverse=True)
    available_sectors = sorted(df[df['Sector'] != 'Nacional']['Sector'].unique())

except Exception as e:
    st.error(f"Error al cargar o procesar los datos: {e}")
    st.stop()


# ==============================================================================
# 5. FUNCI칍N DE PREDICCI칍N SARIMA - Fase 3
# ==============================================================================
def sarima_forecast(df_clean, sector_name, years_to_predict=5):
    """
    Entrena un modelo SARIMA y genera una predicci칩n para el sector dado.
    """

    df_sector = df_clean[
        (df_clean['Sector'] == sector_name) &
        (df_clean['Emisiones_netas'] > 0)
    ].sort_values(by='A칌O')

    if df_sector.empty or len(df_sector) < 5:
        st.warning(f"Se necesitan al menos 5 puntos de datos hist칩ricos para pronosticar el sector '{sector_name}'.")
        return None, None

    ts = df_sector.set_index('A칌O')['Emisiones_netas']

    try:
        model = pm.auto_arima(
            ts,
            test='adf',
            m=1,
            seasonal=False,
            trace=False,
            error_action='ignore',
            suppress_warnings=True,
            stepwise=True,
            n_jobs=-1
        )
    except Exception as e:
        st.error(f"Error al entrenar el modelo SARIMA: {e}")
        return None, None

    forecast_results = model.predict(n_periods=years_to_predict, return_conf_int=True)
    forecast = forecast_results[0]
    conf_int = forecast_results[1]

    last_year = ts.index.max()
    future_years = [last_year + i for i in range(1, years_to_predict + 1)]

    df_forecast = pd.DataFrame({
        'A칌O': future_years,
        'Emisiones_netas': forecast.values,
        'L칤mite Inferior (95%)': conf_int[:, 0],
        'L칤mite Superior (95%)': conf_int[:, 1]
    })

    df_forecast['Tipo'] = 'Pron칩stico'
    ts_df = ts.reset_index()
    ts_df['Tipo'] = 'Hist칩rico'

    df_plot = pd.concat([ts_df, df_forecast.drop(columns=['L칤mite Inferior (95%)', 'L칤mite Superior (95%)'])])

    return df_plot, df_forecast


# ==============================================================================
# 6. INTERFAZ Y AN츼LISIS - Fase 2
# ==============================================================================

# Funci칩n de formato
def format_co2(value):
    return f"{value:,.2f} Mt CO2-eq".replace('.', 'X').replace(',', '.').replace('X', ',')


st.title("游뻟릖 GEI-Colombia Data Insights")
st.markdown("##### Inventario Nacional de Gases de Efecto Invernadero por Sector y A침o (Mt CO2-eq)")
st.divider()

# 7. BARRA LATERAL (Filtros)
st.sidebar.header("Filtros de An치lisis")

# Filtros para el MODO COMPARATIVO (Aqu칤 se usan available_years)
st.sidebar.markdown("### 1. An치lisis Comparativo")
year_A = st.sidebar.selectbox(
    "A침o Base (A)",
    options=available_years,
    index=0
)

year_B_options = [y for y in available_years if y != year_A]
year_B = st.sidebar.selectbox(
    "A침o de Comparaci칩n (B)",
    options=year_B_options,
    index=min(0, len(year_B_options) - 1)
)

st.sidebar.markdown("---")

# Filtro para el MODO POR SECTOR (Tendencia) (Aqu칤 se usan available_sectors)
st.sidebar.markdown("### 2. An치lisis por Sector (Tendencia Hist칩rica)")
selected_sector_trend = st.sidebar.selectbox(
    "Selecciona un Sector",
    options=['TOTAL NACIONAL'] + available_sectors,
    index=0
)


# 8. TARJETAS DE EMISIONES TOTALES (KPIs)
st.header(f"Total Nacional - A침o Base: {year_A}")

df_kpi_A = df[(df['A칌O'] == year_A) & (df['Sector'] == 'Nacional')].iloc[0]
df_kpi_B = df[(df['A칌O'] == year_B) & (df['Sector'] == 'Nacional')].iloc[0]

emisiones_netas_A = df_kpi_A['Emisiones_netas']
emisiones_netas_B = df_kpi_B['Emisiones_netas']
delta = (emisiones_netas_A - emisiones_netas_B)
delta_pct = f"({(delta / emisiones_netas_B) * 100:,.1f}%)"
delta_text = format_co2(delta)

col1, col2, col3 = st.columns(3)

with col1:
    st.metric(
        label="Emisiones Netas Totales",
        value=format_co2(emisiones_netas_A),
        delta=f"{delta_text} vs {year_B} {delta_pct}",
        delta_color="inverse"
    )

with col2:
    st.metric(
        label="Emisiones Brutas Totales",
        value=format_co2(df_kpi_A['Total_Emisiones']),
    )

with col3:
    st.metric(
        label="Absorciones Totales",
        value=format_co2(df_kpi_A['Absorciones']),
        delta="Emisiones Brutas - Absorciones = Netas",
        delta_color="off"
    )

st.divider()

# 9. AN츼LISIS COMPARATIVO SECTORIAL
st.header(f"Gr치fico Comparativo por Sector: {year_A} vs. {year_B}")

df_comp_A = df[(df['A칌O'] == year_A) & (df['Sector'] != 'Nacional')]
df_comp_B = df[(df['A칌O'] == year_B) & (df['Sector'] != 'Nacional')]

df_comp = pd.concat([df_comp_A[['A칌O', 'Sector', 'Emisiones_netas']],
                     df_comp_B[['A칌O', 'Sector', 'Emisiones_netas']]])

df_comp['Emisiones (Mt CO2-eq)'] = df_comp['Emisiones_netas']
df_comp['A칌O'] = df_comp['A칌O'].astype(str)

fig_comp = px.bar(
    df_comp,
    x='Sector',
    y='Emisiones (Mt CO2-eq)',
    color='A칌O',
    barmode='group',
    title=f'Emisiones Netas por Sector Principal ({year_A} vs {year_B})',
    template='plotly_white'
)
fig_comp.update_layout(xaxis_title="Sector Principal", yaxis_title="Emisiones Netas (Mt CO2-eq)")
st.plotly_chart(fig_comp, use_container_width=True)


st.divider()

# 10. AN츼LISIS POR SECTOR (TENDENCIA HIST칍RICA)
st.header(f"Tendencia Hist칩rica de Emisiones Netas: {selected_sector_trend}")

if selected_sector_trend == 'TOTAL NACIONAL':
    df_trend = df[df['Sector'] == 'Nacional']
else:
    df_trend = df[df['Sector'] == selected_sector_trend]

fig_trend = px.line(
    df_trend,
    x='A칌O',
    y='Emisiones_netas',
    title=f'Evoluci칩n de Emisiones Netas para el Sector: {selected_sector_trend}',
    markers=True,
    template='plotly_white'
)
fig_trend.update_layout(xaxis_title="A침o", yaxis_title="Emisiones Netas (Mt CO2-eq)")
fig_trend.update_traces(line=dict(color='#2A8F93'))
st.plotly_chart(fig_trend, use_container_width=True)

st.markdown("#### Datos Crudos Seleccionados")
st.dataframe(df_trend[['A칌O', 'Sector', 'Total_Emisiones', 'Absorciones', 'Emisiones_netas']].sort_values(by='A칌O', ascending=False).set_index('A칌O'), use_container_width=True)


# ------------------------------
# 11. INTERFAZ Y EJECUCI칍N DEL MODELO SARIMA
# ------------------------------
st.divider()
st.header("游댩 Predicci칩n SARIMA por Sector")
st.markdown("##### Proyecci칩n de Emisiones Netas a futuro, basada en datos hist칩ricos. (Mt CO2-eq)")

prediction_sector = st.selectbox(
    "Selecciona el Sector para Pronosticar",
    options=available_sectors,
    index=0
)

forecast_periods = st.slider(
    "A침os a pronosticar a futuro:",
    min_value=1, max_value=10, value=5
)

# Llamada a la funci칩n de pron칩stico
df_plot_pred, df_forecast_table = sarima_forecast(df, prediction_sector, forecast_periods)

if df_plot_pred is not None:

    # Gr치fico de la predicci칩n (Hist칩rico + Pron칩stico)
    fig_pred = px.line(
        df_plot_pred,
        x='A칌O',
        y='Emisiones_netas',
        color='Tipo',
        title=f'Predicci칩n de Emisiones Netas para el Sector: {prediction_sector}',
        template='plotly_white'
    )

    # A침adir el intervalo de confianza (치rea sombreada)
    if df_forecast_table is not None:
        fig_pred.add_traces(
            px.scatter(df_forecast_table, x='A칌O', y='Emisiones_netas').data
        )
        fig_pred.add_traces(
            px.area(
                df_forecast_table,
                x='A칌O',
                y='L칤mite Superior (95%)',
                custom_data=['L칤mite Inferior (95%)']
            ).update_traces(
                fillcolor='rgba(173, 216, 230, 0.5)',
                line=dict(width=0),
                showlegend=False,
                hovertemplate="L칤mite Superior: %{y:.2f} Mt CO2-eq<br>L칤mite Inferior: %{customdata[0]:.2f} Mt CO2-eq<extra></extra>"
            ).data
        )

    st.plotly_chart(fig_pred, use_container_width=True)

    st.markdown("#### Proyecci칩n de Emisiones Netas (Mt CO2-eq)")
    st.dataframe(
        df_forecast_table[['A칌O', 'Emisiones_netas', 'L칤mite Inferior (95%)', 'L칤mite Superior (95%)']].rename(columns={'Emisiones_netas': 'Predicci칩n'}),
        use_container_width=True
    )